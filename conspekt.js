
/* 

   NodeJS — это JavaScript-окружение построенное на движке Chrome V8 (он очень эффективно интерпретирует js в машинный 
код);  NodeJS работает в режиме runtime - работает пока запущен; NodeJS — серверный js; NodeJS это тот же js + некоторые
дополнительные фичи: работа с файлами, создание серверов и т.д.  В NodeJS 1 поток, как и в js

   Node.js следует модульной системе, а встроенная функция require - самый простой способ включить модули, которые 
существуют в отдельных файлах 

*/



Комманды:

node -v                          показывает установленную версия nodeJS
node                             запускает сессию nodeJS - интерактивную среду nodeJS с командами; можно писать js и терминал будет его 
                                 понимать; если закончить текущую сессию nodeJS, например командой .exit, то при новом входе не будут  
                                 доступны данные, например переменные или функции, из прошлой сессии
node <jsFile>                    для запуска файла на nodeJs в терминале указываем путь к файлу; разрешение .js можно не писать

npm -v                           показывает установленную версия nodeJS package manager
npm init                         инициирует проект; мы попадаем в wizard {установщик базовых полей package.json}, где отвечаем на вопросы
npm init -y                      инициирует проект без ответа на вопросы
npm i                            устанавливает все пакеты, указанные в package.json
npm i <packages>                 устанавливает пакеты {модуль} в папку node_modules, которые пойдут в проект - не только для  
                                 разработки; такие пакеты записываются в package.json в поле dependencies; они будут в нашем приложении
npm i <package>@<version>        устанавливает заданную версию пакета
npm i <packages> -D              устанавливает пакеты, как пакеты только для разработки; такие пакеты не пойдут в приложение
npm i -g <packages>              устанавливает пакеты глобально, в node_modules их не будет
npm i <packages> --no-save       устанавливает пакеты без сохранения в package.json
npm rm [-g] <packages>           удаляет локальные {глобальные с флагом -g} пакеты; вложенные {от которых зависит пакет} не удаляются
npm up [-g] <packages>           обновляет все перечисленные пакеты до последней версии
npm run <scriptName>             запускает приложение через скрипты, установленные в package.json в поле scripts; так же скрипты npm 
                                 могут запускать другие скрипты npm, например {"build": "npm run scss && npm run uglify"}

ncu                              показывает пакеты, которые можно обновить {если установлен пакет npm-check-updates}
ncu -u                           обновляет файл package.json {если установлен пакет npm-check-updates}, заменяя версии зависимостей


/* 

   В новой версии Node.js npm пакеты (локальные) нужно запускать с помощью утилиты npx. Например: npx webpack вместо 
webpack;  в поле scripts в package.json можно не писать npx. Так же npx сначало устанавливает модуль, если он не установлен, 
а затем он отрабатывает, после чего модуль удаляется; например: npx create-react-app my-app  сначало установит модуль 
create-react-app, который потом создаст проект my-app, а потом create-react-app удалится

   В папке node_modules у установленных пакетов обычно есть несколько зависимостей (вложенные пакеты), которые можно посмотреть   
в поле dependencies в package.json для каждого пакета. Эти зависимости так же устанавливаются в папку node_modules. 
Получается цепочка зависимостей для работы нашего приложения; т.е. все зависимости из dependencies будут в приложении

devDependencies — пакеты, которые нужны для разработки. Всякие галпы и плагины к ним обычно подпадают в эту категорию.
dependencies — пакеты, от которых ваш пакет зависит непосредственно: как правило — библиотеки; они все ставятся в node_modules.

В production версию продукта попадают не все модули, использующиеся при разработке. Модули из devDependencies не попадут 
в production (при npm run build), только модули из dependencies!  
Но это не касается webpack - в финальный bundle попадут все зависимости:
   https://jsramblings.com/do-dependencies-devdependencies-matter-when-using-webpack
   https://stackoverflow.com/questions/40143357/do-you-put-babel-and-webpack-in-devdependencies-or-dependencies 

Пока не импортировали в проект из node_modules установленный модуль, он в проект не попадает!


                  Основное различие между локальными и глобальными пакетами заключается в следующем: 
- локальные пакеты устанавливаются в каталог, в котором мы запускаем npm i <packages>, и помещаются в node_modules в этом
  каталоге 
- все глобальные пакеты помещаются в одно место в нашей системе (место зависит от настроек), независимо от того, где мы 
  запускаем npm install npm i -g <package>; обновление глобального пакета заставит все проекты использовать новую версию, что 
  может привести к плохим последствиям, т.к. некоторые пакеты могут нарушить совместимость с другими зависимостями и так далее;
  пакет должен быть установлен глобально, когда он предоставляет исполняемую команду, запускаемую из оболочки (CLI), и он 
  повторно используется в проектах (npm, create-react-app, mocha, react-native-cli, nodemon...);  
  По дефолту глобальные пакеты загружаются по такому пути  C:\Users\Anton\AppData\Roaming\npm\node_modules (базовые глобальные
  пакеты: browser-sync, create-react-app, firebase-tools, gulp, json-server, npm-check-updates, rimraf, yarn)

   Например, если chalk установить глобально, то к нему не будет доступа из проекта; для того, что бы получить доступ, можно 
установить модуль require-global; что бы команды chalk были доступны из терминала нужен модуль chalk-cli 

      Почему нам нужно установить gulp глобально и локально?
При установке инструмента глобально он будет использоваться пользователем как утилита командной строки где угодно, 
в том числе вне проектов node. Глобальные установки для проекта node плохи, потому что они затрудняют развертывание.


   package-lock.json служит для сохранения конкретных версий всех зависимостей, которые мы устанавливаем в проект (включая все
вложенные). Это полезно, если, например, другой разработчик разворачивает мой проект, и вроде бы все то же самое, а проект
не работает. А все потому что где то какая то вложенная зависимость установилась не в той версии и в ней что то поменялось 

*/


Пакеты:

npm-check-updates                проверяет и обновляет зависимости в package.json до последних версий, игнорируя указанные версии
chalk                            подсветка текста в консоле
nodemon                          перезапускает сервер при изменениях в файлах